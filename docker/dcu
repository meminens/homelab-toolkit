#!/bin/bash

#================================================================================#
#                                                                                #
#                            dcu - Docker Compose Utility                        #
#                                                                                #
#  A powerful and user-friendly command-line utility for managing multiple       #
#  Docker Compose projects. Simplifies common operations like starting,          #
#  stopping, and checking the status of services. Includes an advanced update    #
#  checker that identifies services with newer container images available.       #
#                                                                                #
#  Features:                                                                     #
#    - Manage all services at once or target specific ones.                      #
#    - Comprehensive status view of all containers and compose services.         #
#    - Interactive update checker.                                               #
#    - Parallel processing for faster status and update checks.                  #
#    - Color-coded output for improved readability.                              #
#    - Progress bars for long-running operations.                                #
#                                                                                #
#  Author: meminens@github & varios LLMs                                         #
#  License: MIT                                                                  #
#                                                                                #
#================================================================================#

#--------------------------------------------------------------------------------#
# SCRIPT CONFIGURATION
#--------------------------------------------------------------------------------#

DEFAULT_BASE_DIR="$HOME/Docker/Hub"
BASE_DIR="${DCU_BASE_DIR:-$DEFAULT_BASE_DIR}"
MAX_PARALLEL_JOBS=16

#--------------------------------------------------------------------------------#
# GLOBAL VARIABLES & STYLES
#--------------------------------------------------------------------------------#

GREEN='\033[32m'
RED='\033[31m'
BLUE='\033[34m'
YELLOW='\033[33m'
CYAN='\033[36m'
NC='\033[0m'

declare -a FAILED_SERVICES=()
declare -a SUCCESS_SERVICES=()
declare -a SELECTED_SERVICES=()

#--------------------------------------------------------------------------------#
# HELPER & UTILITY FUNCTIONS
#--------------------------------------------------------------------------------#

parse_selection() {
    local selection="$1"
    shift
    local -a available_services=("$@")
    
    SELECTED_SERVICES=()
    
    IFS=',' read -ra PARTS <<< "$selection"
    for part in "${PARTS[@]}"; do
        part=$(echo "$part" | tr -d ' ')
        
        if [[ "$part" =~ ^[0-9]+$ ]]; then
            local index=$((part - 1))
            if [[ $index -ge 0 && $index -lt ${#available_services[@]} ]]; then
                SELECTED_SERVICES+=("${available_services[$index]}")
            else
                echo -e "${RED}'$part' is out of range. Please choose from the listed options.${NC}"
                return 1
            fi
        else
            echo -e "${RED}Invalid format: $part (enter 1,2,3 or 'a' for all, 'q' to exit)${NC}"
            return 1
        fi
    done
    
    local -a unique_services=()
    for service in "${SELECTED_SERVICES[@]}"; do
        if [[ ! " ${unique_services[*]} " =~ " ${service} " ]]; then
            unique_services+=("$service")
        fi
    done
    SELECTED_SERVICES=("${unique_services[@]}")
    
    return 0
}

log_warn() {
    echo -e "${YELLOW}[WARN]  $(date '+%Y-%m-%d %H:%M:%S') - $*${NC}"
}

log_error() {
    echo -e "${RED}[ERROR] $(date '+%Y-%m-%d %H:%M:%S') - $*${NC}"
}

find_compose_file() {
    local dir="$1"
    for file in docker-compose.yml docker-compose.yaml compose.yaml compose.yml; do
        if [[ -f "$dir/$file" ]]; then
            echo "$file"
            return 0
        fi
    done
    return 1
}

progress_bar() {
    local current="$1"
    local total="$2"
    local width=50
    local percent=$((100 * current / total))
    local completed=$((width * percent / 100))
    local remaining=$((width - completed))
    
    local bar_completed=$(printf "%${completed}s" | tr " " "#")
    local bar_remaining=$(printf "%${remaining}s" | tr " " "-")
    
    if [[ "$current" != "$total" ]]; then
        printf "\r[%s%s] %s/%s " "$bar_completed" "$bar_remaining" "$current" "$total"
    else
        printf "\r[%s%s] %s/%s \n" "$bar_completed" "$bar_remaining" "$current" "$total"
    fi
}

#--------------------------------------------------------------------------------#
# UPDATE FUNCTIONALITY
#--------------------------------------------------------------------------------#

apply_selected_updates() {
    local BASE_DIR="$1"
    shift
    local -a services_to_update=("$@")
    
    if [[ ${#services_to_update[@]} -eq 0 ]]; then
        log_error "No services selected for update"
        return 1
    fi
    
    FAILED_SERVICES=()
    SUCCESS_SERVICES=()
    
    for service in "${services_to_update[@]}"; do
        local service_dir="$BASE_DIR/$service"
        
        echo -e "${CYAN}Updating $service${NC}"
        
        local status_file=$(mktemp)
        
        (
            cd "$service_dir" || exit 1
            
            local compose_file
            compose_file=$(find_compose_file "$service_dir")
            if [[ $? -ne 0 ]]; then
                echo "ERROR:$service:No compose file found" > "$status_file"
                exit 1
            fi
            
            if ! docker compose -f "$compose_file" down --remove-orphans; then
                echo "ERROR:$service:Failed to stop" > "$status_file"
                exit 1
            fi

            if ! docker compose -f "$compose_file" pull; then
                echo "ERROR:$service:Failed to pull" > "$status_file"
                exit 1
            fi

            if ! docker compose -f "$compose_file" up -d --remove-orphans; then
                echo "ERROR:$service:Failed to restart" > "$status_file"
                exit 1
            fi

            echo "SUCCESS:$service" > "$status_file"
        )
        
        local result=$(cat "$status_file")
        rm -f "$status_file"
        
        local status=$(echo "$result" | cut -d: -f1)
        local service_name=$(echo "$result" | cut -d: -f2)
        
        case "$status" in
            "SUCCESS")
                SUCCESS_SERVICES+=("$service_name")
                ;;
            "ERROR")
                FAILED_SERVICES+=("$service_name")
                local error_msg=$(echo "$result" | cut -d: -f3-)
                ;;
        esac
    done
    
    if [[ ${#SUCCESS_SERVICES[@]} -gt 0 ]]; then
        echo ""
        echo -e "${GREEN}Updated services:${NC}"
        for service in "${SUCCESS_SERVICES[@]}"; do
            echo -e "  ${GREEN}✓${NC} $service"
        done
    fi
    if [[ ${#FAILED_SERVICES[@]} -gt 0 ]]; then
        echo ""
        echo -e "${RED}Services with failed updates:${NC}"
        for service in "${FAILED_SERVICES[@]}"; do
            echo -e "  ${RED}✗${NC} $service"
        done
    fi
}

check_service_updates() {
    local service_name="$1"
    local service_dir="$2"
    
    cd "$service_dir" || return 1
    
    local compose_file
    compose_file=$(find_compose_file "$service_dir")
    if [[ $? -ne 0 ]]; then
        echo "ERROR:$service_name:No compose file found"
        return 1
    fi
    
    local regctl_bin=""
    if command -v regctl >/dev/null 2>&1; then
        regctl_bin="regctl"
    else
        echo "ERROR:$service_name:regctl not found - install regctl for reliable update checking"
        return 1
    fi
    
    local services_json
    services_json=$(docker compose -f "$compose_file" config --format json 2>/dev/null)
    
    if [[ -z "$services_json" ]]; then
        echo "ERROR:$service_name:Cannot parse compose file"
        return 1
    fi
    
    local update_info=""
    local updates_available=false
    
    local services_data
    services_data=$(echo "$services_json" | jq -r '.services | to_entries[] | "\(.key)|\(.value.image // "unknown")"' 2>/dev/null)
    
    if [[ -n "$services_data" ]]; then
        while IFS='|' read -r compose_service image; do
            [[ -z "$compose_service" || -z "$image" ]] && continue
            
            if [[ "$image" != *":"* ]]; then
                image="$image:latest"
            fi
            
            local running_containers
            running_containers=$(docker compose -f "$compose_file" ps -q "$compose_service" 2>/dev/null)
            if [[ -z "$running_containers" ]]; then
                if ! docker image inspect "$image" >/dev/null 2>&1; then
                    update_info="${update_info}    ${YELLOW}$compose_service:${NC} $image\n"
                    updates_available=true
                fi
                continue
            fi
            
            local local_hash
            local_hash=$(docker image inspect "$image" --format '{{.RepoDigests}}' 2>/dev/null)
            
            local remote_hash
            if remote_hash=$(timeout 10 $regctl_bin -v error image digest --list "$image" 2>/dev/null); then
                if [[ -n "$remote_hash" ]] && [[ "$local_hash" != *"$remote_hash"* ]]; then
                    update_info="${update_info}    ${CYAN}$compose_service:${NC} $image\n"
                    updates_available=true
                fi
            else
                update_info="${update_info}    ${YELLOW}$compose_service:${NC} $image\n"
            fi
            
        done <<< "$services_data"
    fi
    
    if [[ "$updates_available" == true ]]; then
        echo "UPDATES_AVAILABLE:$service_name:$update_info"
    else
        echo "UP_TO_DATE:$service_name"
    fi
    
    return 0
}

export -f check_service_updates find_compose_file
export BASE_DIR YELLOW NC CYAN GREEN RED BLUE

check_all_updates() {
    local BASE_DIR="$1"
    
    if ! command -v regctl >/dev/null 2>&1; then
        log_error "regctl not found. Install regctl for reliable update checking:"
        log_error "e.g., sudo pacman -S regclient"
        return 1
    fi
    if ! command -v jq >/dev/null 2>&1; then
        log_error "jq not found. Install jq to parse compose files:"
        log_error "e.g., sudo pacman -S jq"
        return 1
    fi
    
    local services=()
    cd "$BASE_DIR" || return 1
    for dir in */; do
        if find_compose_file "$dir" >/dev/null 2>&1; then
            services+=("$(basename "$dir")")
        fi
    done
    
    if [[ ${#services[@]} -eq 0 ]]; then
        log_warn "No Docker Compose services found in $BASE_DIR"
        return 0
    fi
        
    local total_count=${#services[@]}
    local services_with_updates=()
    local processed_count=0
    
    progress_bar 0 "$total_count"
    
    local -a NoUpdates=()
    local -a GotUpdates=()
    local -a GotErrors=()
    
    local XargsAsync=""
    if (echo "test" | xargs -P 2 >/dev/null 2>&1) && [[ "$MAX_PARALLEL_JOBS" != 0 ]]; then
        XargsAsync="-P $MAX_PARALLEL_JOBS"
    else
        XargsAsync=""
        log_warn "Missing POSIX xargs support for parallelism, falling back to sequential processing."
    fi
    
    while read -r line; do
        ((processed_count++))
        progress_bar "$processed_count" "$total_count"
        
        local status=$(echo "$line" | cut -d: -f1)
        local service_name=$(echo "$line" | cut -d: -f2)
        local details=$(echo "$line" | cut -d: -f3-)
        
        case "$status" in
            UPDATES_AVAILABLE) GotUpdates+=("$service_name:$details") ;;
            UP_TO_DATE) NoUpdates+=("$service_name") ;;
            ERROR) GotErrors+=("$service_name:$details") ;;
            *) log_error "Unexpected output: $line" ;;
        esac
    done < <(
        printf '%s\n' "${services[@]}" | xargs $XargsAsync -I {} bash -c 'check_service_updates "{}" "$BASE_DIR/{}"'
    )
    
    IFS=$'\n'
    NoUpdates=($(sort <<<"${NoUpdates[*]:-}"))
    GotUpdates=($(sort <<<"${GotUpdates[*]:-}"))
    GotErrors=($(sort <<<"${GotErrors[*]:-}"))
    unset IFS

    if [[ -n ${GotErrors[*]:-} ]]; then
        echo -e "${RED}Errors:${NC}"
        for error in "${GotErrors[@]}"; do
            local service_name=$(echo "$error" | cut -d: -f1)
            local message=$(echo "$error" | cut -d: -f2-)
            echo -e "${RED}✗ $service_name${NC} - Error: $message"
        done
    fi

    if [[ -n ${GotUpdates[*]:-} ]]; then
        echo -e "${GREEN}Updates Available:${NC}"
        for service in "${GotUpdates[@]}"; do
            services_with_updates+=("$service")
            local service_name=$(echo "$service" | cut -d: -f1)
            local details=$(echo "$service" | cut -d: -f2-)
            echo -e "${YELLOW}📦 $service_name${NC}"
            echo -e "$details"
        done
    fi
    
    if [[ ${#services_with_updates[@]} -gt 0 ]]; then
        echo -e "${GREEN}Select Updates:${NC}"
        
        local update_service_names=()
        for service in "${services_with_updates[@]}"; do
            local service_name=$(echo "$service" | cut -d: -f1)
            update_service_names+=("$service_name")
        done
        
        for i in "${!update_service_names[@]}"; do
            echo -e "  ${CYAN}$((i+1))${NC}. ${update_service_names[$i]}"
        done
        while true; do
            echo "Choose services to update (e.g., 1,2,3 or 'a' for all, 'q' to quit):"
            read -p "> " selection
            
            case "$selection" in
                "q"|"Q")
                    return 0
                    ;;
                "a"|"A")
                    apply_selected_updates "$BASE_DIR" "${update_service_names[@]}"
                    break
                    ;;
                "")
                    continue
                    ;;
                *)
                    if parse_selection "$selection" "${update_service_names[@]}"; then
                        if [[ ${#SELECTED_SERVICES[@]} -gt 0 ]]; then
                            apply_selected_updates "$BASE_DIR" "${SELECTED_SERVICES[@]}"
                            break
                        else
                            log_warn "No services were selected."
                        fi
                    else
                        log_error "Invalid selection format. Please try again."
                    fi
                    ;;
            esac
        done
    else
        echo -e "${GREEN}✔ All services are up to date!${NC}"
    fi
}

#--------------------------------------------------------------------------------#
# SERVICE MANAGEMENT FUNCTIONS
#--------------------------------------------------------------------------------#

manage_services() {
    local action=$1
    shift
    local -a service_names=("$@")
    
    # If no services specified, operate on all
    if [[ ${#service_names[@]} -eq 0 ]]; then
        manage_all_services "$action"
        return
    fi
    
    # Operate on specific services
    for service_name in "${service_names[@]}"; do
        local service_dir="$BASE_DIR/$service_name"
    
        if [[ ! -d "$service_dir" ]]; then
            echo -e "${RED}[ERROR] Service '$service_name' not found in $BASE_DIR${NC}"
            continue
        fi
    
        local compose_file
        compose_file=$(find_compose_file "$service_dir")
        if [[ $? -ne 0 ]]; then
            echo -e "${RED}[ERROR] No compose file found for service '$service_name'${NC}"
            continue
        fi
    
        cd "$service_dir" || {
            echo -e "${RED}[ERROR] Could not change to directory for '$service_name'${NC}"
            continue
        }

        local is_running=false
        if docker compose -f "$compose_file" ps -q 2>/dev/null | grep -q .; then
            is_running=true
        fi

        if [[ "$action" == "start" && "$is_running" == true ]]; then
            echo -e "${GREEN}✔ No action taken. '$service_name' is already running.${NC}"
            continue
        fi
        if [[ "$action" == "stop" && "$is_running" == false ]]; then
            echo -e "${GREEN}✔ No action taken. '$service_name' is already stopped.${NC}"
            continue
        fi

        echo -e "${CYAN}>>> $service_name${NC}"
    
        case "$action" in
            "start")
                docker compose -f "$compose_file" up -d --remove-orphans
                ;;
            "stop")
                docker compose -f "$compose_file" down --remove-orphans
                ;;
            "restart")
                if [[ "$is_running" == true ]]; then
                    docker compose -f "$compose_file" down --remove-orphans
                    if [[ $? -ne 0 ]]; then
                        echo -e "${RED}[ERROR] Failed to stop '$service_name', restart aborted.${NC}"
                        continue
                    fi
                fi
                docker compose -f "$compose_file" up -d --remove-orphans
                ;;
        esac
    done
}

manage_all_services() {
    local action=$1
    
    FAILED_SERVICES=()
    local actions_taken=0

    local services=()
    cd "$BASE_DIR" || return 1
    for dir in */; do
        if find_compose_file "$dir" >/dev/null 2>&1; then
            services+=("$(basename "$dir")")
        fi
    done
    
    if [[ ${#services[@]} -eq 0 ]]; then
        log_warn "No Docker Compose services found in $BASE_DIR"
        return 0
    fi
    
    local compose_command=""
    case "$action" in
        "start") compose_command="up -d --remove-orphans" ;;
        "stop") compose_command="down --remove-orphans" ;;
        "restart") compose_command="restart" ;;
    esac

    for service in "${services[@]}"; do
        local service_dir="$BASE_DIR/$service"
        
        cd "$service_dir" || {
            log_error "Could not change to directory: $service_dir"
            FAILED_SERVICES+=("$service")
            continue
        }

        local compose_file
        compose_file=$(find_compose_file "$service_dir")
        if [[ $? -ne 0 ]]; then
            log_error "No compose file found for $service"
            FAILED_SERVICES+=("$service")
            continue
        fi

        local is_running=false
        if docker compose -f "$compose_file" ps -q 2>/dev/null | grep -q .; then
            is_running=true
        fi

        if [[ "$action" == "start" && "$is_running" == true ]]; then
            continue
        elif [[ "$action" == "stop" && "$is_running" == false ]]; then
            continue
        fi
        
        echo -e "${CYAN}>>> $service${NC}"
        actions_taken=$((actions_taken + 1))
        
        if [[ "$action" == "restart" ]]; then
            if [[ "$is_running" == true ]]; then
                if ! docker compose -f "$compose_file" down --remove-orphans; then
                    FAILED_SERVICES+=("$service")
                    continue
                fi
            fi
            if ! docker compose -f "$compose_file" up -d --remove-orphans; then
                FAILED_SERVICES+=("$service")
            fi
        else
            if ! docker compose -f "$compose_file" $compose_command; then
                FAILED_SERVICES+=("$service")
            fi
        fi
    done

    if [[ ${#FAILED_SERVICES[@]} -gt 0 ]]; then
        echo -e "${RED}Failure Summary:${NC}"
        for service in "${FAILED_SERVICES[@]}"; do
            echo -e "  ${RED}✗${NC} $service"
        done
    elif [[ $actions_taken -eq 0 && "$action" == "start" ]]; then
        echo -e "${GREEN}✓ All services are already running.${NC}"
    elif [[ $actions_taken -gt 0 && "$action" == "start" ]]; then
        echo -e "${GREEN}✓ All services are now running.${NC}"
    fi
}

get_enhanced_status() {
    
    echo -e "${GREEN}Running Containers:${NC}"
    if [[ $(docker ps -q | wc -l) -gt 0 ]]; then
        printf "%-28s %-28s %-20s\n" "NAME" "UPTIME" "PORTS"
        docker ps --format "{{.Names}}\t{{.Status}}\t{{.Ports}}" | sort | while IFS=$'\t' read -r name status ports; do
            clean_ports=""
            if [[ -n "$ports" ]]; then
                clean_ports=$(echo "$ports" | grep -oE '0\.0\.0\.0:([0-9]+)' | cut -d: -f2 | tr '\n' ',' | sed 's/,$//')
                if [[ -z "$clean_ports" ]]; then
                    clean_ports=$(echo "$ports" | grep -oE '[0-9]+/tcp|[0-9]+/udp' | cut -d/ -f1 | tr '\n' ',' | sed 's/,$//')
                fi
            fi
            [[ -z "$clean_ports" ]] && clean_ports="-"
            printf "%-28s %-28s %-20s\n" "$name" "$status" "$clean_ports"
        done
    else
        echo -e "${YELLOW}No containers currently running${NC}"
    fi
    
    local all_services=()
    cd "$BASE_DIR" || return 1
    for dir in */; do
        if find_compose_file "$dir" >/dev/null 2>&1; then
            all_services+=("$(basename "$dir")")
        fi
    done

    local running_list=()
    local stopped_list=()
    local running_services=0
    local stopped_services=0
    local total_services=0

    check_service_running() {
        local service="$1"
        local service_dir="$BASE_DIR/$service"
        local compose_file
        compose_file=$(find_compose_file "$service_dir")
        if [[ $? -ne 0 ]]; then
            echo "$service:stopped"
            return
        fi
        if docker compose -f "$service_dir/$compose_file" ps -q 2>/dev/null | grep -q .; then
            echo "$service:running"
        else
            echo "$service:stopped"
        fi
    }

    export BASE_DIR
    export -f find_compose_file check_service_running

    local results
    results=$(printf '%s\n' "${all_services[@]}" | xargs -P ${MAX_PARALLEL_JOBS:-8} -I {} bash -c 'check_service_running "$@"' _ {})

    for line in $results; do
        service="${line%%:*}"
        state="${line##*:}"
        total_services=$((total_services + 1))
        if [[ "$state" == "running" ]]; then
            running_list+=("$service")
            running_services=$((running_services + 1))
        else
            stopped_list+=("$service")
            stopped_services=$((stopped_services + 1))
        fi
    done

    IFS=$'\n' running_list=($(sort <<<"${running_list[*]}")); unset IFS
    IFS=$'\n' stopped_list=($(sort <<<"${stopped_list[*]}")); unset IFS

    if [[ ${#running_list[@]} -gt 0 ]]; then
        echo -e "\n${GREEN}Running Services:${NC}"
        for service in "${running_list[@]}"; do
            echo -e "${GREEN}✓${NC} $service"
        done
    fi

    if [[ ${#stopped_list[@]} -gt 0 ]]; then
        echo -e "\n${RED}Stopped Services:${NC}"
        for service in "${stopped_list[@]}"; do
            echo -e "${RED}✗${NC} $service"
        done
    fi
    
    printf "\n${BLUE}%-20s${NC} %s\n" "Total containers:" "$(docker ps -aq | wc -l)"
    printf "${GREEN}%-20s${NC} %s\n" "Running containers:" "$(docker ps -q | wc -l)"
    printf "${BLUE}%-20s${NC} %s\n" "Total services:" "$total_services"
    printf "${GREEN}%-20s${NC} %s\n" "Running services:" "$running_services"
    printf "${RED}%-20s${NC} %s\n" "Stopped services:" "$stopped_services"
}

show_help() {
    echo "dcu - Docker Compose Utility"
    echo "A script to simplify management of multiple Docker Compose projects."
    echo
    echo "USAGE:"
    echo "  $0 [COMMAND] [SERVICES...]"
    echo
    echo "COMMANDS:"
    echo "  status                    Show container status and statistics (default)"
    echo "  start|st [services...]    Start all services or specific ones"
    echo "  stop|sp [services...]     Stop all services or specific ones"
    echo "  restart|rs [services...]  Restart all services or specific ones"
    echo "  update|up                 Interactively check for and apply updates"
    echo "  help|h                    Show this help message"
    echo
    echo "CONFIGURATION:"
    echo "  Base Directory (DCU_BASE_DIR): $BASE_DIR"
    echo "  Max Parallel Jobs: $MAX_PARALLEL_JOBS"
    echo
    echo "EXAMPLES:"
    echo "  $0                     # Show status (default action)"
    echo "  $0 start               # Start all services"
    echo "  $0 st webapp           # Start just the 'webapp' service"
    echo "  $0 stop api db         # Stop the 'api' and 'db' services"
    echo "  $0 rs api db           # Restart the 'api' and 'db' services"
    echo "  $0 restart             # Restart all services"
    echo "  $0 update              # Check all services for updates"
}

#--------------------------------------------------------------------------------#
# SCRIPT ENTRYPOINT
#--------------------------------------------------------------------------------#

if [[ $# -eq 0 ]]; then
    get_enhanced_status
    exit 0
fi

if [[ ! -d "$BASE_DIR" ]]; then
    log_error "Base directory '$BASE_DIR' not found. Set DCU_BASE_DIR environment variable or create the directory."
    exit 1
fi

case "$1" in
    start|st)
        shift
        manage_services "start" "$@"
        ;;
    stop|sp)
        shift
        manage_services "stop" "$@"
        ;;
    restart|rs)
        shift
        manage_services "restart" "$@"
        ;;
    status)
        get_enhanced_status
        ;;
    update|up)
        check_all_updates "$BASE_DIR"
        ;;
    help|h)
        show_help
        ;;
    *)
        echo "Error: Invalid command '$1'"
        echo
        show_help
        exit 1
        ;;
esac